import {Resend} from 'resend'
import {TRPCError} from '@trpc/server'
import {z} from 'zod'
import type {StudioRoleType} from '@play/supabase-client'
import {StudioRole} from '@play/supabase-client'
import {protectedProcedure, router} from '../index'
import {AuditAction, logAuditEvent} from '../lib/audit'
import {
  RATE_LIMIT_CONFIGS,
  getRateLimitKey,
  isRateLimited,
} from '../lib/rate-limit'

// Only owners can manage invites
const MANAGE_ROLES: StudioRoleType[] = [StudioRole.OWNER]

export const inviteRouter = router({
  /**
   * List pending invites for a studio
   */
  list: protectedProcedure
    .input(z.object({studioId: z.string().uuid()}))
    .query(async ({ctx, input}) => {
      const {user, supabase} = ctx

      // Check user is OWNER or ADMIN of studio
      const {data: member} = await supabase
        .from('studio_members')
        .select('role')
        .eq('studio_id', input.studioId)
        .eq('user_id', user.id)
        .single()

      if (!member || !MANAGE_ROLES.includes(member.role as StudioRoleType)) {
        throw new TRPCError({
          code: 'FORBIDDEN',
          message: 'You do not have permission to view invites',
        })
      }

      const {data: invites, error} = await supabase
        .from('invites')
        .select('id, email, role, created_at, accepted_at')
        .eq('studio_id', input.studioId)
        .is('accepted_at', null)
        .order('created_at', {ascending: false})

      if (error) {
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message,
        })
      }

      return invites || []
    }),

  /**
   * Create an invite to a studio
   */
  create: protectedProcedure
    .input(
      z.object({
        studioId: z.string().uuid(),
        email: z.string().email(),
        role: z.enum(['OWNER', 'MEMBER', 'VIEWER']).default('MEMBER'),
      }),
    )
    .mutation(async ({ctx, input}) => {
      const {user, supabase, env} = ctx

      // Rate limit invite creation
      if (
        isRateLimited(
          getRateLimitKey(user.id, 'invite.create'),
          RATE_LIMIT_CONFIGS.invites,
        )
      ) {
        throw new TRPCError({
          code: 'TOO_MANY_REQUESTS',
          message: 'Too many invites sent. Please wait a moment.',
        })
      }

      // Check user is OWNER or ADMIN of studio
      const {data: member} = await supabase
        .from('studio_members')
        .select('role')
        .eq('studio_id', input.studioId)
        .eq('user_id', user.id)
        .single()

      if (!member || !MANAGE_ROLES.includes(member.role as StudioRoleType)) {
        throw new TRPCError({
          code: 'FORBIDDEN',
          message: 'You do not have permission to invite users',
        })
      }

      // Only owners can invite as owner
      if (input.role === 'OWNER' && member.role !== StudioRole.OWNER) {
        throw new TRPCError({
          code: 'FORBIDDEN',
          message: 'Only owners can invite other owners',
        })
      }

      // Check if there's already a pending invite for this email
      const {data: existingInvite} = await supabase
        .from('invites')
        .select('id')
        .eq('studio_id', input.studioId)
        .eq('email', input.email)
        .is('accepted_at', null)
        .single()

      if (existingInvite) {
        throw new TRPCError({
          code: 'CONFLICT',
          message: 'An invite for this email is already pending',
        })
      }

      // Check if user is already a member
      const {data: existingMember} = await supabase
        .from('profiles')
        .select('user_id')
        .eq('email', input.email)
        .single()

      if (existingMember) {
        const {data: isMember} = await supabase
          .from('studio_members')
          .select('user_id')
          .eq('studio_id', input.studioId)
          .eq('user_id', existingMember.user_id)
          .single()

        if (isMember) {
          throw new TRPCError({
            code: 'CONFLICT',
            message: 'This user is already a member of the studio',
          })
        }
      }

      // Create invite (token is auto-generated by DB)
      const {data: invite, error} = await supabase
        .from('invites')
        .insert({
          studio_id: input.studioId,
          email: input.email,
          role: input.role,
        })
        .select()
        .single()

      if (error) {
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message,
        })
      }

      await logAuditEvent(supabase, {
        userId: user.id,
        userEmail: user.email,
        action: AuditAction.INVITE_CREATE,
        studioId: input.studioId,
        targetType: 'invite',
        targetId: String(invite.id),
        metadata: {invitedEmail: input.email, role: input.role},
      })

      // Send invitation email
      if (env.RESEND_API_KEY) {
        // Get studio info for email
        const {data: studio} = await supabase
          .from('studios')
          .select('name, slug')
          .eq('id', input.studioId)
          .single()

        // Get inviter's profile
        const {data: inviterProfile} = await supabase
          .from('profiles')
          .select('display_name, email')
          .eq('user_id', user.id)
          .single()

        const resend = new Resend(env.RESEND_API_KEY)
        const studioUrl = env.STUDIO_URL || 'https://studio.play.link'
        const acceptUrl = `${studioUrl}/invite/${invite.token}`
        const inviterName =
          inviterProfile?.display_name || inviterProfile?.email || 'A team member'
        const studioName = studio?.name || 'a studio'

        await resend.emails.send({
          from: 'Play.link <invites@play.link>',
          to: [input.email],
          subject: `You've been invited to join ${studioName} on Play.link`,
          html: `
            <div style="font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; max-width: 560px; margin: 0 auto; padding: 40px 20px; background: #0f172a;">
              <h1 style="color: #ffffff; font-size: 28px; font-weight: bold; text-align: center; margin: 0 0 24px;">
                You're Invited!
              </h1>
              <p style="color: #cbd5e1; font-size: 16px; line-height: 24px; margin: 0 0 16px;">
                ${inviterName} has invited you to join <strong style="color: #ffffff">${studioName}</strong> as a <strong style="color: #ffffff">${input.role.toLowerCase()}</strong> on Play.link.
              </p>
              <p style="color: #cbd5e1; font-size: 16px; line-height: 24px; margin: 0 0 16px;">
                Click the button below to accept the invitation:
              </p>
              <div style="text-align: center; margin: 32px 0;">
                <a href="${acceptUrl}" style="background-color: #8b5cf6; border-radius: 8px; color: #ffffff; font-size: 16px; font-weight: 500; padding: 12px 24px; text-decoration: none; display: inline-block;">
                  Accept Invitation
                </a>
              </div>
              <p style="color: #64748b; font-size: 14px; margin-top: 32px;">
                This invitation expires in 7 days. If you didn't expect this email, you can safely ignore it.
              </p>
              <p style="color: #64748b; font-size: 14px;">
                â€” The Play.link Team
              </p>
            </div>
          `,
        })
      } else {
        console.warn('[invite.create] RESEND_API_KEY not set, skipping email')
      }

      return invite
    }),

  /**
   * Accept an invite using the token
   */
  accept: protectedProcedure
    .input(z.object({token: z.string().uuid()}))
    .mutation(async ({ctx, input}) => {
      const {user, supabase} = ctx

      // Get the invite
      const {data: invite, error: inviteError} = await supabase
        .from('invites')
        .select('id, studio_id, email, role, accepted_at, expires_at')
        .eq('token', input.token)
        .single()

      if (inviteError || !invite) {
        throw new TRPCError({
          code: 'NOT_FOUND',
          message: 'Invite not found or has expired',
        })
      }

      if (invite.accepted_at) {
        throw new TRPCError({
          code: 'BAD_REQUEST',
          message: 'This invite has already been accepted',
        })
      }

      // Check if invite has expired
      if (invite.expires_at && new Date(invite.expires_at) < new Date()) {
        throw new TRPCError({
          code: 'BAD_REQUEST',
          message: 'This invite has expired',
        })
      }

      // Verify the email matches the user
      const {data: profile} = await supabase
        .from('profiles')
        .select('email')
        .eq('user_id', user.id)
        .single()

      if (
        !profile ||
        profile.email.toLowerCase() !== invite.email.toLowerCase()
      ) {
        throw new TRPCError({
          code: 'FORBIDDEN',
          message: 'This invite was sent to a different email address',
        })
      }

      // Check if already a member
      const {data: existingMember} = await supabase
        .from('studio_members')
        .select('user_id')
        .eq('studio_id', invite.studio_id)
        .eq('user_id', user.id)
        .single()

      if (existingMember) {
        // Mark invite as accepted anyway
        await supabase
          .from('invites')
          .update({accepted_at: new Date().toISOString()})
          .eq('id', invite.id)

        throw new TRPCError({
          code: 'CONFLICT',
          message: 'You are already a member of this studio',
        })
      }

      // Add user to studio
      const {error: memberError} = await supabase
        .from('studio_members')
        .insert({
          studio_id: invite.studio_id,
          user_id: user.id,
          role: invite.role,
        })

      if (memberError) {
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: memberError.message,
        })
      }

      // Mark invite as accepted
      await supabase
        .from('invites')
        .update({accepted_at: new Date().toISOString()})
        .eq('id', invite.id)

      await logAuditEvent(supabase, {
        userId: user.id,
        userEmail: user.email,
        action: AuditAction.INVITE_ACCEPT,
        studioId: invite.studio_id,
        targetType: 'invite',
        targetId: String(invite.id),
        metadata: {role: invite.role},
      })

      return {success: true, studioId: invite.studio_id}
    }),

  /**
   * Delete/revoke an invite
   */
  delete: protectedProcedure
    .input(z.object({id: z.number()}))
    .mutation(async ({ctx, input}) => {
      const {user, supabase} = ctx

      // Get the invite to check studio
      const {data: invite, error: inviteError} = await supabase
        .from('invites')
        .select('studio_id')
        .eq('id', input.id)
        .single()

      if (inviteError || !invite) {
        throw new TRPCError({
          code: 'NOT_FOUND',
          message: 'Invite not found',
        })
      }

      // Check user is OWNER or ADMIN of studio
      const {data: member} = await supabase
        .from('studio_members')
        .select('role')
        .eq('studio_id', invite.studio_id)
        .eq('user_id', user.id)
        .single()

      if (!member || !MANAGE_ROLES.includes(member.role as StudioRoleType)) {
        throw new TRPCError({
          code: 'FORBIDDEN',
          message: 'You do not have permission to delete invites',
        })
      }

      const {error} = await supabase.from('invites').delete().eq('id', input.id)

      if (error) {
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message,
        })
      }

      await logAuditEvent(supabase, {
        userId: user.id,
        userEmail: user.email,
        action: AuditAction.INVITE_REVOKE,
        studioId: invite.studio_id,
        targetType: 'invite',
        targetId: String(input.id),
      })

      return {success: true}
    }),

  /**
   * Get invite details by token (public info for accepting)
   */
  getByToken: protectedProcedure
    .input(z.object({token: z.string().uuid()}))
    .query(async ({ctx, input}) => {
      const {supabase} = ctx

      const {data: invite, error} = await supabase
        .from('invites')
        .select(
          `
          id,
          email,
          role,
          accepted_at,
          studios (
            id,
            slug,
            name,
            avatar_url
          )
        `,
        )
        .eq('token', input.token)
        .single()

      if (error || !invite) {
        throw new TRPCError({
          code: 'NOT_FOUND',
          message: 'Invite not found',
        })
      }

      return invite
    }),
})
