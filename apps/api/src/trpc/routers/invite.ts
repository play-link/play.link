import {TRPCError} from '@trpc/server'
import {z} from 'zod'
import type {OrgRoleType} from '@play/supabase-client'
import {OrgRole} from '@play/supabase-client'
import {protectedProcedure, router} from '../index'
import {AuditAction, logAuditEvent} from '../lib/audit'
import {
  RATE_LIMIT_CONFIGS,
  getRateLimitKey,
  isRateLimited,
} from '../lib/rate-limit'

// Roles that can manage invites
const MANAGE_ROLES: OrgRoleType[] = [OrgRole.OWNER, OrgRole.ADMIN]

export const inviteRouter = router({
  /**
   * List pending invites for an organization
   */
  list: protectedProcedure
    .input(z.object({organizationId: z.string().uuid()}))
    .query(async ({ctx, input}) => {
      const {user, supabase} = ctx

      // Check user is OWNER or ADMIN of org
      const {data: member} = await supabase
        .from('organization_members')
        .select('role')
        .eq('organization_id', input.organizationId)
        .eq('user_id', user.id)
        .single()

      if (!member || !MANAGE_ROLES.includes(member.role as OrgRoleType)) {
        throw new TRPCError({
          code: 'FORBIDDEN',
          message: 'You do not have permission to view invites',
        })
      }

      const {data: invites, error} = await supabase
        .from('invites')
        .select('id, email, role, created_at, accepted_at')
        .eq('organization_id', input.organizationId)
        .is('accepted_at', null)
        .order('created_at', {ascending: false})

      if (error) {
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message,
        })
      }

      return invites || []
    }),

  /**
   * Create an invite to an organization
   */
  create: protectedProcedure
    .input(
      z.object({
        organizationId: z.string().uuid(),
        email: z.string().email(),
        role: z.enum(['OWNER', 'ADMIN', 'MEMBER']).default('MEMBER'),
      }),
    )
    .mutation(async ({ctx, input}) => {
      const {user, supabase} = ctx

      // Rate limit invite creation
      if (
        isRateLimited(
          getRateLimitKey(user.id, 'invite.create'),
          RATE_LIMIT_CONFIGS.invites,
        )
      ) {
        throw new TRPCError({
          code: 'TOO_MANY_REQUESTS',
          message: 'Too many invites sent. Please wait a moment.',
        })
      }

      // Check user is OWNER or ADMIN of org
      const {data: member} = await supabase
        .from('organization_members')
        .select('role')
        .eq('organization_id', input.organizationId)
        .eq('user_id', user.id)
        .single()

      if (!member || !MANAGE_ROLES.includes(member.role as OrgRoleType)) {
        throw new TRPCError({
          code: 'FORBIDDEN',
          message: 'You do not have permission to invite users',
        })
      }

      // Only owners can invite as owner
      if (input.role === 'OWNER' && member.role !== OrgRole.OWNER) {
        throw new TRPCError({
          code: 'FORBIDDEN',
          message: 'Only owners can invite other owners',
        })
      }

      // Check if there's already a pending invite for this email
      const {data: existingInvite} = await supabase
        .from('invites')
        .select('id')
        .eq('organization_id', input.organizationId)
        .eq('email', input.email)
        .is('accepted_at', null)
        .single()

      if (existingInvite) {
        throw new TRPCError({
          code: 'CONFLICT',
          message: 'An invite for this email is already pending',
        })
      }

      // Check if user is already a member
      const {data: existingMember} = await supabase
        .from('profiles')
        .select('user_id')
        .eq('email', input.email)
        .single()

      if (existingMember) {
        const {data: isMember} = await supabase
          .from('organization_members')
          .select('user_id')
          .eq('organization_id', input.organizationId)
          .eq('user_id', existingMember.user_id)
          .single()

        if (isMember) {
          throw new TRPCError({
            code: 'CONFLICT',
            message: 'This user is already a member of the organization',
          })
        }
      }

      // Create invite (token is auto-generated by DB)
      const {data: invite, error} = await supabase
        .from('invites')
        .insert({
          organization_id: input.organizationId,
          email: input.email,
          role: input.role,
        })
        .select()
        .single()

      if (error) {
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message,
        })
      }

      await logAuditEvent(supabase, {
        userId: user.id,
        userEmail: user.email,
        action: AuditAction.INVITE_CREATE,
        organizationId: input.organizationId,
        targetType: 'invite',
        targetId: String(invite.id),
        metadata: {invitedEmail: input.email, role: input.role},
      })

      // TODO: Send email with invite link containing token

      return invite
    }),

  /**
   * Accept an invite using the token
   */
  accept: protectedProcedure
    .input(z.object({token: z.string().uuid()}))
    .mutation(async ({ctx, input}) => {
      const {user, supabase} = ctx

      // Get the invite
      const {data: invite, error: inviteError} = await supabase
        .from('invites')
        .select('id, organization_id, email, role, accepted_at, expires_at')
        .eq('token', input.token)
        .single()

      if (inviteError || !invite) {
        throw new TRPCError({
          code: 'NOT_FOUND',
          message: 'Invite not found or has expired',
        })
      }

      if (invite.accepted_at) {
        throw new TRPCError({
          code: 'BAD_REQUEST',
          message: 'This invite has already been accepted',
        })
      }

      // Check if invite has expired
      if (invite.expires_at && new Date(invite.expires_at) < new Date()) {
        throw new TRPCError({
          code: 'BAD_REQUEST',
          message: 'This invite has expired',
        })
      }

      // Verify the email matches the user
      const {data: profile} = await supabase
        .from('profiles')
        .select('email')
        .eq('user_id', user.id)
        .single()

      if (
        !profile ||
        profile.email.toLowerCase() !== invite.email.toLowerCase()
      ) {
        throw new TRPCError({
          code: 'FORBIDDEN',
          message: 'This invite was sent to a different email address',
        })
      }

      // Check if already a member
      const {data: existingMember} = await supabase
        .from('organization_members')
        .select('user_id')
        .eq('organization_id', invite.organization_id)
        .eq('user_id', user.id)
        .single()

      if (existingMember) {
        // Mark invite as accepted anyway
        await supabase
          .from('invites')
          .update({accepted_at: new Date().toISOString()})
          .eq('id', invite.id)

        throw new TRPCError({
          code: 'CONFLICT',
          message: 'You are already a member of this organization',
        })
      }

      // Add user to organization
      const {error: memberError} = await supabase
        .from('organization_members')
        .insert({
          organization_id: invite.organization_id,
          user_id: user.id,
          role: invite.role,
        })

      if (memberError) {
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: memberError.message,
        })
      }

      // Mark invite as accepted
      await supabase
        .from('invites')
        .update({accepted_at: new Date().toISOString()})
        .eq('id', invite.id)

      await logAuditEvent(supabase, {
        userId: user.id,
        userEmail: user.email,
        action: AuditAction.INVITE_ACCEPT,
        organizationId: invite.organization_id,
        targetType: 'invite',
        targetId: String(invite.id),
        metadata: {role: invite.role},
      })

      return {success: true, organizationId: invite.organization_id}
    }),

  /**
   * Delete/revoke an invite
   */
  delete: protectedProcedure
    .input(z.object({id: z.number()}))
    .mutation(async ({ctx, input}) => {
      const {user, supabase} = ctx

      // Get the invite to check org
      const {data: invite, error: inviteError} = await supabase
        .from('invites')
        .select('organization_id')
        .eq('id', input.id)
        .single()

      if (inviteError || !invite) {
        throw new TRPCError({
          code: 'NOT_FOUND',
          message: 'Invite not found',
        })
      }

      // Check user is OWNER or ADMIN of org
      const {data: member} = await supabase
        .from('organization_members')
        .select('role')
        .eq('organization_id', invite.organization_id)
        .eq('user_id', user.id)
        .single()

      if (!member || !MANAGE_ROLES.includes(member.role as OrgRoleType)) {
        throw new TRPCError({
          code: 'FORBIDDEN',
          message: 'You do not have permission to delete invites',
        })
      }

      const {error} = await supabase.from('invites').delete().eq('id', input.id)

      if (error) {
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message,
        })
      }

      await logAuditEvent(supabase, {
        userId: user.id,
        userEmail: user.email,
        action: AuditAction.INVITE_REVOKE,
        organizationId: invite.organization_id,
        targetType: 'invite',
        targetId: String(input.id),
      })

      return {success: true}
    }),

  /**
   * Get invite details by token (public info for accepting)
   */
  getByToken: protectedProcedure
    .input(z.object({token: z.string().uuid()}))
    .query(async ({ctx, input}) => {
      const {supabase} = ctx

      const {data: invite, error} = await supabase
        .from('invites')
        .select(
          `
          id,
          email,
          role,
          accepted_at,
          organizations (
            id,
            slug,
            name,
            avatar_url
          )
        `,
        )
        .eq('token', input.token)
        .single()

      if (error || !invite) {
        throw new TRPCError({
          code: 'NOT_FOUND',
          message: 'Invite not found',
        })
      }

      return invite
    }),
})
